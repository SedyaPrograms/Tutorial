# -*- coding: utf-8 -*-
"""
Created on Mon Dec  7 17:52:08 2020

@author: Kirill Sedov

Здравствуйте, эта программа призвана проверить возможность перколяции при заданном коэфициенте(kPercolation)
судь программы:
    у нас есть обработанная матрица n*n(расписывать способ обработки не буду сделаю остановку в коде), представляющая собой набор единиц и нулей
    и нам бы узнать можно ли спуститься по единичкам с первой строчки на последнюю(по-простому пишу)
    
моя идея: используя функции проверки пройти этот путь, закрывая неправильные нулями 

Почему я выбрал этот способ? Ответ: мне он показался интересным в исполнении, именно такой способ я придумал в первые 10 минут после того как услышал об этой задаче      
"""
import numpy as np
"""
Итак, первая функция проверки checkPointDown, является ключевой функцией проверки, тк наша цель в самом низу
Что делает эта функция? сейчас расскажу! 
1)проверяем что под нами 
2)проверяем что слева
3)проверяем что с права 
 т.к. это ключевая функция, то именно в ней "вшита" фраза print("Перколяция выполнима"), которая говорит о успешном выполнении
но если мы пришли в тупик, недостигнув цели, то мы зануляем последнюю единицу и повторяем путь( тут либо мы занулим всё, что касается вехней строчки, либо найдем путь вниз ) 

Другие две функции проверки являются частными случаями функции checkPointDown, чтобы избежать зацикливания( например шагули вправо, потом влево, вправо, влево и т.д.)  

И функция checkPoint - это функция - переходник, мне нужны было как-то сохранить стартовую точку (saveI,saveJ), чтобы к ней возвращаться, для повторной проверки 


В функциях есть так называемые инструменты проверки (использовались при создании, чтоб видеть что делает программа), сейчас они закомментированы, 
чтобы программа выссылала меньше информации в командную строку


Перколяция выполнима в [строка];[столбец] - показывает из какой точки начинается наша успешная лестница единичек( помним, что массивы с нуля начинаются )
"""

def checkPoint(i,j):
    saveI=i
    saveJ=j
    checkPointDown(i,j,saveI,saveJ)
    return (i,j)    

"Функции оснащены граничными условиями, чтобы не вылезти за рамки массива"   
def checkPointDown(i,j,saveI,saveJ):
    if (i < n-1):                                                                 
        if (i+1 == n-1) & (arr[i+1][j] == 1):
            print("Перколяция выполнима в ",saveI,";", saveJ)                                         
        else:
            if (arr[i+1][j] == 1):
                i=i+1
                'print("DownD",i,";",j)'                                          "Инструмент проверки"
                checkPointDown(i,j,saveI,saveJ)
            else:
                if (j > 0) & (arr[i][j-1] == 1):
                    j=j-1
                    'print("LeftD",i,";",j)'                                      "Инструмент проверки"
                    checkPointLeft(i,j,saveI,saveJ)
                else:
                    if (j < n-1):
                        if(arr[i][j+1] == 1):
                            j=j+1
                            'print("RightD",i,";",j)'                             "Инструмент проверки"   
                            checkPointRight(i,j,saveI,saveJ)
                        else:
                            arr[i][j]=0
                            "print('clear')"                                      "Инструмент проверки, в других функциях аналогично"  
                            if arr[saveI][saveJ] == 1:
                                checkPointDown(saveI, saveJ, saveI, saveJ)
    return  (i,j)  


"Функция  проверяет что под нами, если нуль, то что слева от нас, если опять нуль, то заменяем эту единицу на нуль"                          
def checkPointLeft(i,j,saveI,saveJ):
    if arr[i+1][j] == 1:
        i=i+1
        'print("DownL",i,";",j)'
        checkPointDown(i,j,saveI,saveJ)
    else:
        if (j > 0) & (arr[i][j-1] == 1):
            j=j-1
            'print("LeftL",i,";",j)'
            checkPointLeft(i,j,saveI,saveJ)
        else:
            arr[i][j]=0
            "print('clear')"
            if arr[saveI][saveJ] == 1:
                checkPointDown(saveI, saveJ, saveI, saveJ)
    return (i,j)

   
"Функция  проверяет что под нами, если нуль, то что справа от нас, если опять нуль, то заменяем эту единицу на нуль" 
def checkPointRight(i,j,saveI,saveJ):
    if arr[i+1][j] == 1:
        i=i+1
        'print("DownR",i,";",j)'
        checkPointDown(i,j,saveI,saveJ)
    else:
        if (j < n-1):
            if (arr[i][j+1] == 1):
                j=j+1
                'print("RightR",i,";",j)'
                checkPointRight(i,j,saveI,saveJ)
            else:
                arr[i][j]=0
                "print('clear')"
                if arr[saveI][saveJ] == 1:
                    checkPointDown(saveI, saveJ, saveI, saveJ)
    return (i,j)

"""размерность матрицы, да размерность настраивается в скрипте. Мне не лень сдеть вопросом через input или функцией весь скрипт, просто считаю так правильнее
сразу минус программы: она основанна на рекурсии, поэтому при больших n она заявлиет об ошибке, что максимальная глубина рекурсии превышена в сравнении, 
проще говоря, конфликтует с гнраничными условиями """
n = 35

j=i=0
"Создаю массив n*n, а потом в зависомости от kPercolation присваиваю значения 1 или 0"
arr = []
for i in range(n):
    arr1 = []
    for j in range(n):
        arr1.append(np.random.sample())
    arr.append(arr1) 

"Коэфициент перколяции"
kPercolation = 0.49

j=i=0
for i in range(n):
    for j in range(n):
        if arr[i][j] < kPercolation:
            arr[i][j] = 0 
        else: arr[i][j] = 1        

"""for i in arr:     с этого имеет смыслс снять комеентарий при малом n, например, 10; рисует исходную матрицу(из единичек и нулей)
    print(i)""" 
     
"Теперь будем пытаться узнать можно ли СПУСТИТЬСЯ вниз по единичкам"

"""
Все что было выше - это конечно важные части, но это сердце программы(скрипта): от настройки этого цикла зависит вся программа 
Сложность: настроить так чтобы цикл повторился столько раз, что 
     а)либо закроются все единички "касающиеся" первой строки(т.е обеспечить наглядность не выполнения)
     б)либо единички нас приведут к желаемой нижней     
"""
f=j=i=0

for f in range(0,n,1):
    if arr[0][f] == 1:
       "print('f=',f)"        "Инструмент проверки"
       checkPoint(0, f)
       arr[i][j]=0   
 
"""print('new')                с этого имеет смыслс снять комеентарий при малом n, например, 10; рисует обработанную матрицу матрицу
for i in arr:
    print(i)"""            
            
    
"Итог задачи зависит от случайного расположения 1 и 0 более-менее успешно при kPercolation = 0.49"    